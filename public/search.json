[{"categories":["python开发"],"content":"test tets' test ","date":"2025-03-19","objectID":"/python%E5%BC%80%E5%8F%91/hello_world/:0:0","tags":["python"],"title":"Hello_world","uri":"/python%E5%BC%80%E5%8F%91/hello_world/"},{"categories":["draft"],"content":" Git在工作中经常用到，然后我相信包括我在内大部分人应该都停留在简单的clone,push,pull等等简单的操作上（虽然大部分时候也确实够用了😂）。不过在遇到冲突的时候合并冲突的时候脑子就会一团浆糊，因此我最近仔细学习了一遍git~从命令到原理，希望这篇文章可以帮助到阅读这篇文章的人😉 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:0:0","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"版本控制 版本控制是一个项目开发中非常重要的一环，举一个例子，如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。 为了解决这个问题，人们开发了许多中本地版本控制系统，大多都是采用简单的数据库来记录。但是还有一个非常重要的问题必须解决，那就是如果有多个开发者该怎么办？本地记录固然方便，但是不能解决多个系统的多开发者问题。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:1:0","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"集中化的版本控制系统 集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:1:1","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"分布式版本控制系统 于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:1:2","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"Git下文件的三种状态 Git有三种状态，分别是已提交(committed)，已修改(modified)和已暂存(staged).对应的，Git项目有三个区域，分别是工作区（工作目录），暂存区（索引）、Git目录（git仓库）。 工作区： os上的文件，所有的代码开发编辑在这上面完成，其实这里的工作区就是实际上你操作的文件夹。 暂存区： 可以理解为一个暂存区域，这里面的代码会在下一次commit被提交到Git仓库。不过其实暂存区是一个文件，它保存了下次将要提交的文件列表信息，一般在Git的仓库目录中，按照git的术语叫做“索引”。 Git仓库： 由Git object记录着每一次提交的快照，以及链式结构记录的提交变更历史。这是Git中最重要的部分，从其他计算机克隆仓库时，复制的就是这里的数据。 基本的工作流程就是： 在工作区修改文件 将你想要下次提交的更改选择性暂存 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:2:0","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"Git下的一些基本指令 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:3:0","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"获取git仓库 有两种方式可以获得Git项目仓库： 将一个不是Git仓库的本地目录转换为Git仓库 从其他服务器克隆一个已经存在的Git仓库 方法一（初始化仓库） git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 如果你想追踪某些文件并进行初始提交，可以按如下流程： git add xxx git commit -m 'xxxx' 方法二（克隆一个现有的仓库） git clone https://github.com/libgit2/libgit2 你也可以自定义本地仓库的名字： git clone https://github.com/libgit2/libgit2 xxx Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:3:1","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"一个简单的提交更新的流程 要记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。在这里你可以认为“已跟踪就是你git add 的文件，而未跟踪就是没有被add过的文件（本博客作者拙见）”。 上面这四个状态分别是未追踪，未修改，已修改和已暂存。 我相信你应该可以根据这四个词的意思大致推断出每个状态的含义。 未被add的文件（从未被add）是未追踪状态 add一个文件后该文件变为暂存状态 git status查看文件状态 git status是一个非常有用的指令，它可以帮助你明白你接下来要干什么，限于篇幅（一个人可以专注阅读的最大文字）这里仅仅做一个简单展示（强烈建议你自己在新建一个git仓库后使用add，commit等指令后尝试输入git status试一下）。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： $ git status On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working directory clean 这个命令会告诉你当前的分支名称，工作目录中文件的状态等等。 忽略文件 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子： $ cat .gitignore *.[oa] *~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件. 查看已暂存和未暂存的修改 git diff 可以具体的显示哪些行发生了改变 提交更新 git commit -m ‘xxx’ 如果你不想使用暂存区域，你可以使用git commit -a -m 'xxx'来直接进行提交，使用这个命令Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 查看历史提交 git log ","date":"2025-03-12","objectID":"/posts/9ed4b52/:3:2","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"撤销操作 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令来重新提交： git commit --amend 这个命令作者的理解是可以覆盖上一次的-m中的内容。（他是用一个新的提交替换旧的提交，因此旧提交不会出现在历史中） 取消暂存的文件 假设我们现在修改两个文件： echo 111 \u003e\u003e a.txt echo 111 \u003e\u003e b.txt 我们本来想git add a.txt但是一不小心使用了’git add *’，那么该如何将b.txt取消暂存呢？ 我们输入git status试一下： $ git status On branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: 1.txt modified: a.txt modified: b.txt git status 告诉我们“use “git restore –staged …” to unstage”，请注意这里与官方的教程中“use “git reset HEAD …” to unstage”并不一样，这是因为古早的git reset承载了太多的功能，而git restore是在Git 2.23版本（2019年）引入的新命令，作为更清晰、更专门化的命令之一，与git switch一起被引入，旨在分解git checkout的功能，使得各个命令的职责更明确。 因此我们输入： $ git restore --staged b.txt $ git status On branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: 1.txt modified: a.txt Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: b.txt 撤销对文件的修改 如果我不想保留对某一个文件的修改怎么办呢？（如何将它还原成之前某一个时刻的状态？） 注意看上一个条目的第二段： Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: b.txt 也就是说我们只要执行： git restore b.txt 这样它就会被撤销修改。 请务必记得 git restore 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:3:3","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"远程仓库 通过运行git remote来查看已经配置的远程仓库服务器。如果你是git clone的仓库，那么至少可以看到origin，这是默认的名字。 也可以通过运行git remote -v查看详细的url。 添加远程仓库 git remote add \u003cshortname\u003e \u003curl\u003e添加一个新的远程git仓库，shortname表示一个简写。 从远程仓库抓取与拉取 $ git fetch \u003cremote\u003e 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 当然git pull也可以拉取，但是并不一样，这将在后面提及。 推送到远程仓库 git push \u003cremote\u003e \u003cbranch\u003e,比如当你想将main推送到origin时，你需要执行： $ git push origin main 这里需要注意几点： 首先，你推送的那个服务器要写在第一个位置 你可以直接使用git push，他会帮你自动填充后面 你要有目标服务器的写入权限，而且之前没有人推送过（否则可能会冲突）。 查看远程仓库 git remote show \u003cremote\u003e 远程仓库的重命名与移除 git remote rename \u003cprev\u003e \u003cnext\u003e git remote remove xxx或者git remote rm xxx ","date":"2025-03-12","objectID":"/posts/9ed4b52/:3:4","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"Git分支 分支的好处在于你可以把你的工作从开发主线上分离开，以免影响开发主线。Git的分支是它区别于其他版本管理系统的重要原因，因为Git的分支十分轻量。 Git保存的不是文件的变化和差异，而是一系列不同时刻的快照 快照与备份不同，快照是数据存储的某一时刻的状态记录；备份则是数据存储的某一个时刻的副本。想象你有一个装满玩具的箱子，快照就像给你的玩具箱拍一张全景照片， 备份就像把整个玩具箱复制一份存到阁楼。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:4:0","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"Git存储信息的本质（Git对象） blob对象 首先我们创建两个文件: $ git init $ echo '111' \u003e a.txt $ echo '222' \u003e b.txt $ git add *.txt Git会将整个数据库存储在.git/目录下，此时我们查看.git/objects目录，会发现里面多了两个文件： $ ll total 0 drwxr-xr-x 1 July 197609 0 Mar 14 16:01 58/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 c2/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 info/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 pack/ 58和c2就是多出来的文件，里面放了什么东西？ 打开58，可以发现里面有一个名为“c9bdf9d017fcd178dc8c073cbfcbb7ff240d6c”的文件（c2里面也有一个）。 里面写了什么？使用cat会发现是一串乱码，不过git为我们提供了api工具来查看文件内容。git cat-file [-t] [-p]， -t可以查看object的类型，-p可以查看object储存的具体内容。 git cat-file -t 58c9 blob git cat-file -p 58c9 111 这里要查看内容的话要输入“58c9”，也可以输入“58c9bdf9d017fcd178dc8c073cbfcbb7ff240d6c”，实际上这一串就是当此操作的hash值。这就是开始时 Git 存储内容的方式——一个文件对应一条内容， 以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。 可以发现这个object是一个blob类型的节点，他的内容是111.也就是说这个object存储了a.txt的内容。它只储存的是一个文件的内容，不包括文件名等其他信息。然后将这些信息经过SHA1哈希算法得到对应的哈希值，作为这个object的唯一凭证。 树对象 现在我们创建一个commit git commit -am 'init' 现在再次查看object下的文件： $ ll total 0 drwxr-xr-x 1 July 197609 0 Mar 14 16:54 4c/ drwxr-xr-x 1 July 197609 0 Mar 14 16:54 51/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 58/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 c2/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 info/ drwxr-xr-x 1 July 197609 0 Mar 14 16:01 pack/ 你会发现又多了两个文件4c,51。使用cat-file查看其内容和类型： $ git cat-file -t 4caa tree $ git cat-file -p 4caa 100644 blob 58c9bdf9d017fcd178dc8c073cbfcbb7ff240d6c a.txt 100644 blob c200906efd24ec5e783bee7f23b5d7c941b0c12c b.txt $ git cat-file -p 5104 \\tree 4caaa1a9ae0b274fba9e3675f9ef071616e5b209 author July \u003czhzihao2023@lzu.edu.cn\u003e 1741942475 +0800 committer July \u003czhzihao2023@lzu.edu.cn\u003e 1741942475 +0800 init $ git cat-file -t 5104 commit 第二种Git object类型——tree，它将当前的目录结构打了一个快照。从它储存的内容来看可以发现它储存了一个目录结构（类似于文件夹），以及每一个文件（或者子文件夹）的权限、类型、对应的身份证（SHA1值）、以及文件名。 第三种Git object类型——commit，它储存的是一个提交的信息，包括对应目录结构的快照tree的哈希值，上一个提交的哈希值（这里由于是第一个提交，所以没有父节点。在一个merge提交中还会出现多个父节点），提交的作者以及提交的具体时间，最后是该提交的信息。 分支信息存储在哪里呢？ $ cat .git/refs/heads/master 5104a36b91f41192bff5d90c7cced8afbcf24693 在Git仓库里面，HEAD、分支、普通的Tag可以简单的理解成是一个指针，指向对应commit的SHA1值。(注意这里指向的就是5104那个commit) 当前时刻Git就像下图一样： 至此我们知道了Git是什么储存一个文件的内容、目录结构、commit信息和分支的。其本质上是一个key-value的数据库加上默克尔树形成的有向无环图（DAG）。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:4:1","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"分支简介 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。 让我们新建一个git仓库: $ git init Initialized empty Git repository in C:/study/试验记录/test/.git/ 新建三个文件如下： touch README;touch test.rb;touch LICENSE 此时观察.git目录下的objects： $ ll ./.git/objects/ total 0 drwxr-xr-x 1 July 197609 0 Mar 18 15:25 info/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 pack/ 执行暂存命令： $ git add README test.rb LICENSE $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: LICENSE new file: README new file: test.rb 再次查看.git目录下的objects： $ ll ./.git/objects/ total 0 drwxr-xr-x 1 July 197609 0 Mar 18 15:27 e6/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 info/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 pack/ 😉这里会有小伙伴问了，明明创建了三个文件，为什么文件夹里只多了一个e6文件夹呢？事实上，当文件内容为空时，Git 会为它生成一个特定的 SHA-1 哈希值：e69de29bb2d1d6434b8b29ae775ad8c2e48c5391。无论你暂存多少个空文件，只要内容为空，它们都会共享同一个 Blob 对象，因此 .git/objects/中只会新增一个目录（e6/），其中包含这个唯一的 Blob 对象。 让我们修改README和test.rb再次add观察： $ echo readme \u003e\u003e README ;echo 'test' \u003e\u003e test.rb git add * $ ll ./.git/objects/ total 0 drwxr-xr-x 1 July 197609 0 Mar 18 15:43 81/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 9d/ drwxr-xr-x 1 July 197609 0 Mar 18 15:27 e6/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 info/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 pack/ 此时我们进行commit操作： $ git commit -m 'The initial commit of my project' [master (root-commit) 5cd2079] The initial commit of my project 3 files changed, 2 insertions(+) create mode 100644 LICENSE create mode 100644 README create mode 100644 test.rb 再次查看目录： $ ll ./.git/objects/ total 0 drwxr-xr-x 1 July 197609 0 Mar 18 15:43 32/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 5c/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 81/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 9d/ drwxr-xr-x 1 July 197609 0 Mar 18 15:27 e6/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 info/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 pack/ 当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。 现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树 对象 （记录着目录结构和 blob 对象索引）以及一个 提交 对象（包含着指向前述树对象的指针和所有提交信息）。 让我们查看是否真的如此： $ git cat-file -p 32c5 100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 LICENSE 100644 blob 8178c76d627cade75005b40711b92f4177bc6cfc README 100644 blob 9daeafb9864cf43055ae93beb0afd6c7d144bfa4 test.rb $ git cat-file -t 32c5 tree $ git cat-file -p 5cd2 tree 32c52e68ba2d6782ea0c127570df0ea2b537f706 author July \u003czhzihao2023@lzu.edu.cn\u003e 1742283836 +0800 committer July \u003czhzihao2023@lzu.edu.cn\u003e 1742283836 +0800 The initial commit of my project $ git cat-file -t 5cd2 commit 当前的树结构如下（偷懒用的官方文档中的图片，有时间再画吧。。。） 我们修改任意一个文件后再次提交。 $ echo 123123 \u003e\u003e test.rb $ git add test.rb $ git commit -m \"change\" [master 54e1ea3] change 1 file changed, 1 insertion(+) $ ll ./.git/objects/ total 0 drwxr-xr-x 1 July 197609 0 Mar 18 15:43 32/ drwxr-xr-x 1 July 197609 0 Mar 18 15:51 54/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 5c/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 81/ drwxr-xr-x 1 July 197609 0 Mar 18 15:43 9d/ drwxr-xr-x 1 July 197609 0 Mar 18 15:51 c7/ drwxr-xr-x 1 July 197609 0 Mar 18 15:27 e6/ drwxr-xr-x 1 July 197609 0 Mar 18 15:51 fd/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 info/ drwxr-xr-x 1 July 197609 0 Mar 18 15:25 pack/ 会发现多了三个文件54，c7，fd。 查看其中内容： $ git cat-file -p 54e1 tree fd11b6cf48cd9dbb9c6c047d63f1370697bb2407 parent 5cd2079b476e981c9f3f86b6b2c7187f66452fd0 author July \u003czhzihao2023@lzu.edu.cn\u003e 1742284299 +0800 committer July \u003czhzihao2023@lzu.edu.cn\u003e 1742284299 +0800 change $ git cat-file -p c7bc test 123123 $ git cat-file -p fd11 100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 LICENSE 100644 blob 8178c76d627cade75005b40711b92f4177bc6cfc README 100644 blob c7bc15bebf7caa69e8e6f473c5da515dd0b86e0d test.rb 请观察54e1，你会发现它比之前的commit多了一个parent 5cd2079b476e981c9f3","date":"2025-03-12","objectID":"/posts/9ed4b52/:4:2","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["draft"],"content":"分支创建 使用git branch \u003cname\u003e创建新分支，git创建分支十分简单，他只是为你创建一个可以移动的新的指针。 $ git branch * master $ git branch testing $ git branch * master testing $ git switch testing Switched to branch 'testing' $ git branch master * testing 这个命令会在当前所在的提交对象上创建一个新的指针。 那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为HEAD的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（将HEAD想象为当前分支的别名）。 让我们查看一下： $ cat .git/logs/HEAD 0000000000000000000000000000000000000000 5cd2079b476e981c9f3f86b6b2c7187f66452fd0 July \u003czhzihao2023@lzu.edu.cn\u003e 1742283836 +0800 commit (initial): The initial commit of my project 5cd2079b476e981c9f3f86b6b2c7187f66452fd0 54e1ea31276270458ec461f140864b3a37fccac7 July \u003czhzihao2023@lzu.edu.cn\u003e 1742284299 +0800 commit: change 54e1ea31276270458ec461f140864b3a37fccac7 54e1ea31276270458ec461f140864b3a37fccac7 July \u003czhzihao2023@lzu.edu.cn\u003e 1742285117 +0800 checkout: moving from master to testing 或者使用git log --oneline --decorate来查看。 $ git log --oneline --decorate 54e1ea3 (HEAD -\u003e testing, master) change 5cd2079 The initial commit of my project 你也可以使用git checkout xxx来进行分支切换，但是并不建议，前文中已经提到过git checkout能做的事情太多，容易混淆，建议使用功能更明确的switch。 现在的分支图如下： 那么这样的好处是什么呢？我们现在修改test.rb并再次提交： $ echo new \u003e\u003e test.rb $ git add test.rb $ git commit -m \"new\" [testing b02a51a] new 1 file changed, 1 insertion(+) 此时我们再次查看head： $ git log --oneline --decorate b02a51a (HEAD -\u003e testing) new 54e1ea3 (master) change 5cd2079 The initial commit of my project 也就是说当前的分支图类似这样： 如图，testing分支向前移动了，但是master分支却没有，它仍然指向运行git witch时所指的对象。 这就有意思了，现在我们切换回master分支看看： git switch master 那么现在的分支图应该是这样的： 切换分支一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 现在做一些修改再次提交： $ echo newnew \u003e\u003e test.rb $ git add test.rb $ git commit -m \"change test.rb twice\" [master f60624d] change test.rb twice 1 file changed, 1 insertion(+) $ git log --oneline --decorate f60624d (HEAD -\u003e master) change test.rb twice 54e1ea3 change 5cd2079 The initial commit of my project 现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 也就是说当前的分支图是这样的： 使用git log --oneline --decorate --graph --all查看所有分支。 $ git log --oneline --decorate --graph --all * f60624d (HEAD -\u003e master) change test.rb twice | * b02a51a (testing) new |/ * 54e1ea3 change * 5cd2079 The initial commit of my project 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 ","date":"2025-03-12","objectID":"/posts/9ed4b52/:4:3","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["python"],"content":"之前有一段时间被python的引用搞得头昏脑胀，学了之后现在再看已经记不太清了，于是特来记录一番. ","date":"2025-03-10","objectID":"/posts/2146d33/:0:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"一些基本概念 script 脚本是一个python文件，可以直接运行，但是一般不包含类呀class呀或者一些变量的定义，只是用来执行 module 模块是一个变量，数组，函数和类的集合.模块是一种以.py为后缀的文件，用于表示程序的一部分，模块的名称是该py文件的名称 package 包是指一个文件夹中包含很多module（几个模块的集合）。包体现了模块的机构化管理思想。老版本必须在文件夹下放一个__init__.py，不然不识别，现在可有可无，不过建议加上,该目录下的文件被视为一个单一的包。 #目录结构 . |-- creatures | |-- __init__.py | |-- ch.py | |-- moster.py |-- magic |-- __init__.py |-- magic.py library 一个库是几个包的集合。python中的库并没有具体的定义，着重强调其功能性。 framework 框架，框架与库类似，往往集成了多种库的功能。 ","date":"2025-03-10","objectID":"/posts/2146d33/:1:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"if name==’main': 假设在同一目录下有两个文件m1.py与m2.py 其中m1的内容如下： def f1(): print(\"this is m1\") m2内容如下： from m1 import f1 f1() 执行m2.py，输出将为： this is m1 this is m1 但是如果我们修改m1.py的内容为： def f1(): print(\"this is m1\") if __name__=='__main__': f1() 那么此时再运行m2就会输出一个m1. okay,现在来探究一下__name__.我们现在在m1.py的代码中加入一行代码： def f1(): print(\"this is m1\") print(__name__) if __name__=='__main__': f1() 此时再次执行m1.py，屏幕中将输出： __main__ this is m1 再次执行m2.py,屏幕将输出： m1 this is m1 也就是说在运行m1的时候__name__将等于__main__,而在运行m2时m1中的__name__变为了m1。 name这个变量编译器会自动定义，可以通过print(dir())显示。 修改m1的代码为： print(dir()) def f1(): print(\"this is m1\") print(__name__) a=34 print(dir()) if __name__=='__main__': f1() 执行m1，将输出： ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__'] ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'f1'] this is m1 __main__ 看到这里，我们要知道两个事情，第一个事情是我们在import一个模块时，会自动运行这个模块中的所有代码，这与引用的形式无关，如果你不想执行那么就使用__name__.第二点是不管import几次，同一个文件只会执行一次（解释器发现第一次已经加载了，第二次便不加载了）。 ","date":"2025-03-10","objectID":"/posts/2146d33/:2:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"sys 编写一段python代码如下： import sys print(sys.path) 代码将输出 ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] 这是一个列表，当你在运行一个代码时，python会在这些路径里查找你要引用的模块。 如果找不到要引用的那个包，那么有两种方法来解决。 现在的目录如下： . ├── m1.py ├── m2.py ├── pkg │ ├── __pycache__ │ │ └── run.cpython-312.pyc │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 如果想在m2.py中引用run.py，假设这样写： #m2.py from m1 import f1 import m1 import run import sys print(sys.path) f1() 代码将会报错，这是因为python在当前的path中找不到run，此时可以这样解决： 使用绝对路径引用 #m2.py from m1 import f1 import m1 import pkg.run import sys print(sys.path) f1() 这种方法可以成功是因为pkg位于根目录package下面，python可以找到pkg。 可以手动将m2的路径添加到path中 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') ","date":"2025-03-10","objectID":"/posts/2146d33/:3:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"相对引用（容易犯错） 当前我们的文件目录如下： . └── package ├── m1.py ├── m2.py ├── pkg │ ├── __pycache__ │ │ └── run.cpython-312.pyc │ ├── run2.py │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 此时四个代码文件依次如下： #m1.py import sys print(sys.path) def f1(): print(\"this is m1\") if __name__=='__main__': f1() #m2.py import sys import m1 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') import pkg.run2 #run.py def run1(): print(\"this run1\") run1() #run2.py from .run import run1 def run2(): print(\"this run2\") run1() 此时运行m2.py，代码将输出： ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] this run1 this run1 第一个输出的列表是m2中引用m1时运行m1中的代码print(sys.path)输出的。 第二个输出是run2引用run1时执行run1时得到的 第三个输出时run2自己执行run1()得到的 😉 假设我们将m2的代码修改为： import sys import m1 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') import run2 代码将直接报错： ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] Traceback (most recent call last): File \"/home/zzh/data/attack_based_steal/imp/package/m2.py\", line 5, in \u003cmodule\u003e import run2 File \"/home/zzh/data/attack_based_steal/imp/package/pkg/run2.py\", line 1, in \u003cmodule\u003e from .run import run1 ImportError: attempted relative import with no known parent package 😉 注意这里报错并不是因为m2没有引用到run2。这里的报错与直接执行run2的报错相同。若直接执行run2，代码将报错： Traceback (most recent call last): File \"/home/zzh/data/attack_based_steal/imp/package/pkg/run2.py\", line 1, in \u003cmodule\u003e from .run import run1 ImportError: attempted relative import with no known parent package 这是因为如果使用绝对路径进行引用的时候python使用sys.path来查找模块，如果找不到就报错。但是相对引用是通过模块的__name__来查找的。 在run2中添加一行代码输出__name__: #run2.py print(__name__) from .run import run1 def run2(): print(\"this run2\") run1() 此时分别执行m2与run2，代码将分别输出： pkg.run2 __main__ 也就是说这两种方式下run2的__name__是不一致的。 那么好玩的就来了，如果我强行想避免这种报错怎么办呢？ 修改run2.py的代码如下： print(__name__) __name__ = 'pkg.abc' import sys sys.path.append('/home/zzh/data/attack_based_steal/imp/package') from .run import run1 def run2(): print(\"this run2\") run1() 我们直接修改掉run2的__name__，同时将pkg所在目录添加到sys.path中，这样直接执行run2便不报错了。这是因为相对路径在查找时靠的时__name__,而此时的name告诉python上级目录是pkg，而pkg可以在path下找的，因此便不会再报错了。但是并不推荐这么写😉. 实际上在真实的开发环境中一般也都是运行根目录下的主程序，而不会去直接运行包里面的文件。 再举一个例子，假如此时m2.py引用m1使用相对引用from .m1 import *那么也是会报错的，同理此时的m2的__name__是__main__,因此也找不到父目录。若要修改的话要将m2的__name__修改为’package.abc’然后再将package的上级目录添加到sys.path中。 ","date":"2025-03-10","objectID":"/posts/2146d33/:4:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"init.py init.py 文件主要用来初始化，可以为空。 现有目录如下： . └── package ├── m1.py ├── m2.py ├── pkg │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-312.pyc │ │ ├── run2.cpython-312.pyc │ │ └── run.cpython-312.pyc │ ├── run2.py │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 其中__init__.py中的内容如下from .run2 import run2,那么此时我们就可以在m2.py中编写from pkg import run2。这样写的好处是如果pkg是你自己写的，那么你可以通过这个文件来告诉别人哪些东西可以用，而且也不需要使用者自行查找。 ","date":"2025-03-10","objectID":"/posts/2146d33/:5:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"subpackage .表示当前目录那么..就表示上一级目录。 完结撒花😉 ","date":"2025-03-10","objectID":"/posts/2146d33/:6:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["语法"],"content":"Markdown语法","date":"2025-03-06","objectID":"/posts/6874887/","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"为什么我们需要markdown文档呢？ 一些主要好处在于： Markdown简单易学，没有多余字符，编写内容较快 用Markdown书写时出错的机会更少 可以将内容与视觉显示保持分开 interesting~ ","date":"2025-03-06","objectID":"/posts/6874887/:0:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"标题 从 h2 到 h6的标题在每个级别上都加上一个 # ： ## 标题 ### 标题 #### 标题 ##### 标题 ###### 标题 你还可以添加自定义标题的ID，只需要在标题相同的行中将自定义ID放在花括号中： ### 标题 {#custom-id} 这类似于html中的 \u003ch3 id=\"custom-id\"\u003e标题\u003c/h3\u003e ","date":"2025-03-06","objectID":"/posts/6874887/:1:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"注释 注释与html语言中的注释一样 \u003c!-- 你看不到我 --\u003e ","date":"2025-03-06","objectID":"/posts/6874887/:2:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"水平线 在html中，水平线用 \u003chr\u003e 标签表示。在markdown中，用下面三种方式： ___ 三个连续的下划线 — 三个连续的破折号 *** 三个连续的星号 呈现效果如下： ","date":"2025-03-06","objectID":"/posts/6874887/:3:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"段落 直接按照纯文本的方式即可输出段落，不需要html中用\u003cp\u003e\u003c/p\u003e标签包裹 使用一个空白行来进行换行 ","date":"2025-03-06","objectID":"/posts/6874887/:4:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"强调 ","date":"2025-03-06","objectID":"/posts/6874887/:5:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"加粗 用于强调带有较粗字体的文本片段。 以下文本片段会被 渲染为粗体 **渲染为粗体** __渲染为粗体__ ","date":"2025-03-06","objectID":"/posts/6874887/:5:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"斜体 以下文本将被 渲染为斜体 *斜体* _斜体_ ","date":"2025-03-06","objectID":"/posts/6874887/:5:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"删除线 这段文本将被删除 ~~删除线~~ ","date":"2025-03-06","objectID":"/posts/6874887/:5:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"组合 加粗，斜体和删除线可以组合使用 ","date":"2025-03-06","objectID":"/posts/6874887/:5:4","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加 \u003e : 效果如下 这是一段引用，注意要使用引用的话，箭头应该在一行的行首同时引用也可以嵌套，二级引用是两个箭头 \u003e 这是一段引用 ","date":"2025-03-06","objectID":"/posts/6874887/:5:5","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"列表 ","date":"2025-03-06","objectID":"/posts/6874887/:6:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"无序列表 无序列表没有标号 可以使用如下符号来进行表示： * 一项 - 一项 + 一项 例如： * test * test * test * test * test * test 呈现的效果如下： test test test test test test ","date":"2025-03-06","objectID":"/posts/6874887/:6:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"有序列表 就是带标号的列表 1. test 2. test 3. test 呈现的效果如下： test test test tips 如果你对每一行都是用1. 来进行标号，那么markdown将会自动为每一项标号 ","date":"2025-03-06","objectID":"/posts/6874887/:6:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"代码 ","date":"2025-03-06","objectID":"/posts/6874887/:7:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"行内代码 用 `包装行内代码 tips 如果要包裹的行内代码内包含 ` 可以使用连续的双引号来进行包裹 在这个例子中，`行内代码`将被包裹 效果如下： 在这个例子中，行内代码将被包裹 ","date":"2025-03-06","objectID":"/posts/6874887/:7:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"围栏代码块 使用围栏 ```来生成一段带有语言属性的代码块。 ``` markdown text here 输出的效果如下： text here ","date":"2025-03-06","objectID":"/posts/6874887/:7:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"表格 通过在每个单元格之间添加竖线作为分割线，并在标题下添加一行破折号（也由竖线分割）来创建表格，竖线并不需要竖直对齐 | option | des | | ------ | --- | | data | how are u ? | 呈现的效果如下： option des data how are u ? tips 文本右对齐与居中对齐 在任何标题下方的破折号右侧添加冒号将使该列文本右对齐，在任何标题下方的破折号两侧添加冒号将使该列文本居中对齐 | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的效果如下： Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2025-03-06","objectID":"/posts/6874887/:8:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"链接 ","date":"2025-03-06","objectID":"/posts/6874887/:9:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"基本链接 \u003chttps://www.baidu.com\u003e [bilibili](https://www.bilibili.com/) 呈现的效果如下： https://www.baidu.com bilibili ","date":"2025-03-06","objectID":"/posts/6874887/:9:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"引用式链接 引用式链接是一种特殊的链接，它使URL在markdown中更易于显示和阅读。 引用式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。 [text][id] ··· [id]: http://example.org/ \"title\" 例如： [fixit][fixit-repo] [fixit-repo]: https://github.com/hugo-fixit/FixIt \"A clean, elegant but advanced blog theme for Hugo\" 呈现的效果如下： fixit ","date":"2025-03-06","objectID":"/posts/6874887/:9:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"定位标记 定位标记允许你跳转至同一页面上的指定锚点。例如，每个章节： ## Table of contents * [Ch1](#chapter-1) * [Ch2](#chapter-2) 将跳转到这些部分： ## Ch1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e content ## Ch2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e ","date":"2025-03-06","objectID":"/posts/6874887/:9:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"图片 图片的语法与链接相似，只不过要加一个感叹号 ![Minion](url) 或者 ![text](url) ","date":"2025-03-06","objectID":"/posts/6874887/:10:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"emoji表情支持 emoji表情有多种方式可以在hugo项目中使用。 真开心！ :joy: 效果如下： 真开心！ 😂 更多表情请参考emoji代码~ ","date":"2025-03-06","objectID":"/posts/6874887/:11:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["draft"],"content":"这是 粗体 文本，这是 斜体 文本。 访问 Hugo 网站！ 123123 ","date":"2025-03-05","objectID":"/posts/10efd1f/:0:0","tags":["draft"],"title":"Test","uri":"/posts/10efd1f/"},{"categories":["hello"],"content":"Welcome to Hugo FixIt! This is your very first post. ","date":"2025-03-04","objectID":"/posts/hello-world/:0:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["hello"],"content":"Documentation Head to the documentation page linked below for a complete guidence to get started with the FixIt theme. InstallationGetting StartedContent ManagementAdvanced Usage ","date":"2025-03-04","objectID":"/posts/hello-world/:1:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["hello"],"content":"Feedback Whether it’s questions, ideas, bugs or pull requests, all feedback is welcome! Head over to the issues or discussions tracker. ","date":"2025-03-04","objectID":"/posts/hello-world/:2:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"}]