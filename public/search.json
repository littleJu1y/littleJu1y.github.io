[{"categories":["python"],"content":"之前有一段时间被python的引用搞得头昏脑胀，学了之后现在再看已经记不太清了，于是特来记录一番. ","date":"2025-03-10","objectID":"/posts/2146d33/:0:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"一些基本概念 script 脚本是一个python文件，可以直接运行，但是一般不包含类呀class呀或者一些变量的定义，只是用来执行 module 模块是一个变量，数组，函数和类的集合.模块是一种以.py为后缀的文件，用于表示程序的一部分，模块的名称是该py文件的名称 package 包是指一个文件夹中包含很多module（几个模块的集合）。包体现了模块的机构化管理思想。老版本必须在文件夹下放一个__init__.py，不然不识别，现在可有可无，不过建议加上,该目录下的文件被视为一个单一的包。 #目录结构 . |-- creatures | |-- __init__.py | |-- ch.py | |-- moster.py |-- magic |-- __init__.py |-- magic.py library 一个库是几个包的集合。python中的库并没有具体的定义，着重强调其功能性。 framework 框架，框架与库类似，往往集成了多种库的功能。 ","date":"2025-03-10","objectID":"/posts/2146d33/:1:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"if name==’main': 假设在同一目录下有两个文件m1.py与m2.py 其中m1的内容如下： def f1(): print(\"this is m1\") m2内容如下： from m1 import f1 f1() 执行m2.py，输出将为： this is m1 this is m1 但是如果我们修改m1.py的内容为： def f1(): print(\"this is m1\") if __name__=='__main__': f1() 那么此时再运行m2就会输出一个m1. okay,现在来探究一下__name__.我们现在在m1.py的代码中加入一行代码： def f1(): print(\"this is m1\") print(__name__) if __name__=='__main__': f1() 此时再次执行m1.py，屏幕中将输出： __main__ this is m1 再次执行m2.py,屏幕将输出： m1 this is m1 也就是说在运行m1的时候__name__将等于__main__,而在运行m2时m1中的__name__变为了m1。 name这个变量编译器会自动定义，可以通过print(dir())显示。 修改m1的代码为： print(dir()) def f1(): print(\"this is m1\") print(__name__) a=34 print(dir()) if __name__=='__main__': f1() 执行m1，将输出： ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__'] ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'f1'] this is m1 __main__ 看到这里，我们要知道两个事情，第一个事情是我们在import一个模块时，会自动运行这个模块中的所有代码，这与引用的形式无关，如果你不想执行那么就使用__name__.第二点是不管import几次，同一个文件只会执行一次（解释器发现第一次已经加载了，第二次便不加载了）。 ","date":"2025-03-10","objectID":"/posts/2146d33/:2:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"sys 编写一段python代码如下： import sys print(sys.path) 代码将输出 ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] 这是一个列表，当你在运行一个代码时，python会在这些路径里查找你要引用的模块。 如果找不到要引用的那个包，那么有两种方法来解决。 现在的目录如下： . ├── m1.py ├── m2.py ├── pkg │ ├── __pycache__ │ │ └── run.cpython-312.pyc │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 如果想在m2.py中引用run.py，假设这样写： #m2.py from m1 import f1 import m1 import run import sys print(sys.path) f1() 代码将会报错，这是因为python在当前的path中找不到run，此时可以这样解决： 使用绝对路径引用 #m2.py from m1 import f1 import m1 import pkg.run import sys print(sys.path) f1() 这种方法可以成功是因为pkg位于根目录package下面，python可以找到pkg。 可以手动将m2的路径添加到path中 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') ","date":"2025-03-10","objectID":"/posts/2146d33/:3:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"相对引用（容易犯错） 当前我们的文件目录如下： . └── package ├── m1.py ├── m2.py ├── pkg │ ├── __pycache__ │ │ └── run.cpython-312.pyc │ ├── run2.py │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 此时四个代码文件依次如下： #m1.py import sys print(sys.path) def f1(): print(\"this is m1\") if __name__=='__main__': f1() #m2.py import sys import m1 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') import pkg.run2 #run.py def run1(): print(\"this run1\") run1() #run2.py from .run import run1 def run2(): print(\"this run2\") run1() 此时运行m2.py，代码将输出： ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] this run1 this run1 第一个输出的列表是m2中引用m1时运行m1中的代码print(sys.path)输出的。 第二个输出是run2引用run1时执行run1时得到的 第三个输出时run2自己执行run1()得到的 😉 假设我们将m2的代码修改为： import sys import m1 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') import run2 代码将直接报错： ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] Traceback (most recent call last): File \"/home/zzh/data/attack_based_steal/imp/package/m2.py\", line 5, in \u003cmodule\u003e import run2 File \"/home/zzh/data/attack_based_steal/imp/package/pkg/run2.py\", line 1, in \u003cmodule\u003e from .run import run1 ImportError: attempted relative import with no known parent package 😉 注意这里报错并不是因为m2没有引用到run2。这里的报错与直接执行run2的报错相同。若直接执行run2，代码将报错： Traceback (most recent call last): File \"/home/zzh/data/attack_based_steal/imp/package/pkg/run2.py\", line 1, in \u003cmodule\u003e from .run import run1 ImportError: attempted relative import with no known parent package 这是因为如果使用绝对路径进行引用的时候python使用sys.path来查找模块，如果找不到就报错。但是相对引用是通过模块的__name__来查找的。 在run2中添加一行代码输出__name__: #run2.py print(__name__) from .run import run1 def run2(): print(\"this run2\") run1() 此时分别执行m2与run2，代码将分别输出： pkg.run2 __main__ 也就是说这两种方式下run2的__name__是不一致的。 那么好玩的就来了，如果我强行想避免这种报错怎么办呢？ 修改run2.py的代码如下： print(__name__) __name__ = 'pkg.abc' import sys sys.path.append('/home/zzh/data/attack_based_steal/imp/package') from .run import run1 def run2(): print(\"this run2\") run1() 我们直接修改掉run2的__name__，同时将pkg所在目录添加到sys.path中，这样直接执行run2便不报错了。这是因为相对路径在查找时靠的时__name__,而此时的name告诉python上级目录是pkg，而pkg可以在path下找的，因此便不会再报错了。但是并不推荐这么写😉. 实际上在真实的开发环境中一般也都是运行根目录下的主程序，而不会去直接运行包里面的文件。 再举一个例子，假如此时m2.py引用m1使用相对引用from .m1 import *那么也是会报错的，同理此时的m2的__name__是__main__,因此也找不到父目录。若要修改的话要将m2的__name__修改为’package.abc’然后再将package的上级目录添加到sys.path中。 ","date":"2025-03-10","objectID":"/posts/2146d33/:4:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"init.py init.py 文件主要用来初始化，可以为空。 现有目录如下： . └── package ├── m1.py ├── m2.py ├── pkg │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-312.pyc │ │ ├── run2.cpython-312.pyc │ │ └── run.cpython-312.pyc │ ├── run2.py │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 其中__init__.py中的内容如下from .run2 import run2,那么此时我们就可以在m2.py中编写from pkg import run2。这样写的好处是如果pkg是你自己写的，那么你可以通过这个文件来告诉别人哪些东西可以用，而且也不需要使用者自行查找。 ","date":"2025-03-10","objectID":"/posts/2146d33/:5:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["python"],"content":"subpackage .表示当前目录那么..就表示上一级目录。 完结撒花😉 ","date":"2025-03-10","objectID":"/posts/2146d33/:6:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["语法"],"content":"Markdown语法","date":"2025-03-06","objectID":"/posts/6874887/","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"为什么我们需要markdown文档呢？ 一些主要好处在于： Markdown简单易学，没有多余字符，编写内容较快 用Markdown书写时出错的机会更少 可以将内容与视觉显示保持分开 interesting~ ","date":"2025-03-06","objectID":"/posts/6874887/:0:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"标题 从 h2 到 h6的标题在每个级别上都加上一个 # ： ## 标题 ### 标题 #### 标题 ##### 标题 ###### 标题 你还可以添加自定义标题的ID，只需要在标题相同的行中将自定义ID放在花括号中： ### 标题 {#custom-id} 这类似于html中的 \u003ch3 id=\"custom-id\"\u003e标题\u003c/h3\u003e ","date":"2025-03-06","objectID":"/posts/6874887/:1:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"注释 注释与html语言中的注释一样 \u003c!-- 你看不到我 --\u003e ","date":"2025-03-06","objectID":"/posts/6874887/:2:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"水平线 在html中，水平线用 \u003chr\u003e 标签表示。在markdown中，用下面三种方式： ___ 三个连续的下划线 — 三个连续的破折号 *** 三个连续的星号 呈现效果如下： ","date":"2025-03-06","objectID":"/posts/6874887/:3:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"段落 直接按照纯文本的方式即可输出段落，不需要html中用\u003cp\u003e\u003c/p\u003e标签包裹 使用一个空白行来进行换行 ","date":"2025-03-06","objectID":"/posts/6874887/:4:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"强调 ","date":"2025-03-06","objectID":"/posts/6874887/:5:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"加粗 用于强调带有较粗字体的文本片段。 以下文本片段会被 渲染为粗体 **渲染为粗体** __渲染为粗体__ ","date":"2025-03-06","objectID":"/posts/6874887/:5:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"斜体 以下文本将被 渲染为斜体 *斜体* _斜体_ ","date":"2025-03-06","objectID":"/posts/6874887/:5:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"删除线 这段文本将被删除 ~~删除线~~ ","date":"2025-03-06","objectID":"/posts/6874887/:5:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"组合 加粗，斜体和删除线可以组合使用 ","date":"2025-03-06","objectID":"/posts/6874887/:5:4","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加 \u003e : 效果如下 这是一段引用，注意要使用引用的话，箭头应该在一行的行首同时引用也可以嵌套，二级引用是两个箭头 \u003e 这是一段引用 ","date":"2025-03-06","objectID":"/posts/6874887/:5:5","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"列表 ","date":"2025-03-06","objectID":"/posts/6874887/:6:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"无序列表 无序列表没有标号 可以使用如下符号来进行表示： * 一项 - 一项 + 一项 例如： * test * test * test * test * test * test 呈现的效果如下： test test test test test test ","date":"2025-03-06","objectID":"/posts/6874887/:6:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"有序列表 就是带标号的列表 1. test 2. test 3. test 呈现的效果如下： test test test tips 如果你对每一行都是用1. 来进行标号，那么markdown将会自动为每一项标号 ","date":"2025-03-06","objectID":"/posts/6874887/:6:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"代码 ","date":"2025-03-06","objectID":"/posts/6874887/:7:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"行内代码 用 `包装行内代码 tips 如果要包裹的行内代码内包含 ` 可以使用连续的双引号来进行包裹 在这个例子中，`行内代码`将被包裹 效果如下： 在这个例子中，行内代码将被包裹 ","date":"2025-03-06","objectID":"/posts/6874887/:7:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"围栏代码块 使用围栏 ```来生成一段带有语言属性的代码块。 ``` markdown text here 输出的效果如下： text here ","date":"2025-03-06","objectID":"/posts/6874887/:7:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"表格 通过在每个单元格之间添加竖线作为分割线，并在标题下添加一行破折号（也由竖线分割）来创建表格，竖线并不需要竖直对齐 | option | des | | ------ | --- | | data | how are u ? | 呈现的效果如下： option des data how are u ? tips 文本右对齐与居中对齐 在任何标题下方的破折号右侧添加冒号将使该列文本右对齐，在任何标题下方的破折号两侧添加冒号将使该列文本居中对齐 | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的效果如下： Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2025-03-06","objectID":"/posts/6874887/:8:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"链接 ","date":"2025-03-06","objectID":"/posts/6874887/:9:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"基本链接 \u003chttps://www.baidu.com\u003e [bilibili](https://www.bilibili.com/) 呈现的效果如下： https://www.baidu.com bilibili ","date":"2025-03-06","objectID":"/posts/6874887/:9:1","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"引用式链接 引用式链接是一种特殊的链接，它使URL在markdown中更易于显示和阅读。 引用式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。 [text][id] ··· [id]: http://example.org/ \"title\" 例如： [fixit][fixit-repo] [fixit-repo]: https://github.com/hugo-fixit/FixIt \"A clean, elegant but advanced blog theme for Hugo\" 呈现的效果如下： fixit ","date":"2025-03-06","objectID":"/posts/6874887/:9:2","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"定位标记 定位标记允许你跳转至同一页面上的指定锚点。例如，每个章节： ## Table of contents * [Ch1](#chapter-1) * [Ch2](#chapter-2) 将跳转到这些部分： ## Ch1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e content ## Ch2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e ","date":"2025-03-06","objectID":"/posts/6874887/:9:3","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"图片 图片的语法与链接相似，只不过要加一个感叹号 ![Minion](url) 或者 ![text](url) ","date":"2025-03-06","objectID":"/posts/6874887/:10:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"emoji表情支持 emoji表情有多种方式可以在hugo项目中使用。 真开心！ :joy: 效果如下： 真开心！ 😂 更多表情请参考emoji代码~ ","date":"2025-03-06","objectID":"/posts/6874887/:11:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["draft"],"content":"这是 粗体 文本，这是 斜体 文本。 访问 Hugo 网站！ 123123 ","date":"2025-03-05","objectID":"/posts/10efd1f/:0:0","tags":["draft"],"title":"Test","uri":"/posts/10efd1f/"},{"categories":["hello"],"content":"Welcome to Hugo FixIt! This is your very first post. ","date":"2025-03-04","objectID":"/posts/hello-world/:0:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["hello"],"content":"Documentation Head to the documentation page linked below for a complete guidence to get started with the FixIt theme. InstallationGetting StartedContent ManagementAdvanced Usage ","date":"2025-03-04","objectID":"/posts/hello-world/:1:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["hello"],"content":"Feedback Whether it’s questions, ideas, bugs or pull requests, all feedback is welcome! Head over to the issues or discussions tracker. ","date":"2025-03-04","objectID":"/posts/hello-world/:2:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"}]