[{"categories":null,"content":"过去的事情我已经忘记了很多，但是我仍然记得那个下午。 那是一个阳光明媚的下午，母亲坐在院子里用梳子轻轻地梳理着我家那条狗的毛发。我坐在旁边问她，“妈妈，这样做真能让它好起来吗？”，母亲并没有给我肯定的答复，只是说到“这样也许会让它好受一点”。 我已经不记得那条狗是如何来到我家的，甚至它的样貌我也已经完全记不得了，我只记得它是一条纯黑色的狗，它总是被拴在院子里的一角，那个角落里有一个小窝，它就在那里生活。 那个时候我家里只有一辆摩托车，我爸爸载着我上学，那条黑狗偶尔被放出来，它就跟着摩托车跑。 可是后来它还是死了，我并不知道它具体的死因，听妈妈说，是因为我们出门不在家，奶奶忘记喂食而饿死的，我始终不相信这个理由，那么大，那么壮的狗怎么会这样死去呢？那场病都没有夺取它的生命，怎么会饿死呢？ 可是它确实是不在了，那个狗窝也不在了，在我的家中养过很多条狗，这只却是我记忆里的第一条狗，我仍然记得，在院子里玩耍时的我和它看我时的眼神。 ","date":"2025-05-09","objectID":"/%E9%9A%8F%E7%AC%94/%E5%BE%80%E4%BA%8B/:0:0","tags":null,"title":"往事","uri":"/%E9%9A%8F%E7%AC%94/%E5%BE%80%E4%BA%8B/"},{"categories":null,"content":"基于传统特征的单模态deepfake检测 传统检测技术的通用框架如下图 基于人工特征的融合算法、 手工特征主要是不复杂，容易提取。 目前使用过的方法主要有： 每个视频帧提取cv特征看帧间变化率 生物和生理特征：牙齿和嘴部运动 皮肤颜色变化 音频 翻译 基于单模态的深度伪造检测传统技术 预处理阶段使用帧序列从视频中提取帧，并通过生成频谱图将音频数据转换为图像，以便为处理阶段提取稳健特征。根据提取的特征和处理阶段，传统技术可分为基于手工特征的算法和基于 ML 的算法。 基于人工特征的融合算法 手工制作的特征重量轻、不复杂，而且更容易提取。在这方面，作者提取了纹理特征来分析深层伪造不同区域的不规则性[43]。纹理特征采用 LBP（局部二值模式）方法提取。 该特征仅针对面部区域提取，并使用 MTCNN 分类器进行检测。伽玛校正和帧间面部相似性也被用于检测低收缩图像中的面部区域。 超像素分割用于计算纹理信息。使用 RGB、CIELab 和 LBP 三种不同的方法计算相应区域之间的欧氏距离。图像被划分为多个超像素，以创建显著性。另一方面，作者集合了纹理和伪影信息来检测真实图像和深度伪造图像之间的不一致性[42]。伪影指的是真实赝品和深度赝品中存在的随机和合成噪声干扰。余弦距离测量了真假图像之间纹理不一致的相似距离。分数级融合将纹理不一致性分数和人工痕迹融合在一起，以获得深度赝品检测的综合结果。作者在降维后的面部图像上融合了 fisherface 和 LBP 直方图特征，用于预测深度假货[26]。使用卡尔曼滤波器去除图像中的噪声，并对图像进行归一化处理，以增强图像对比度[25]。 光照变化分析对于检测深度伪造非常有效。为此，Zhu 等人[84] 提取了帧级的光照不一致性，并通过多级特征增强来增强特征级光照。低频域的特征通过 DCT（离散余弦变换）获得，用于捕捉频域的光照变化。通过特征级融合获得深度防伪检测的最终得分。在文献[79]中，作者通过将检测到的人脸划分为 8 × 8 的统一块来计算 DCT 值。一旦定位了人脸，就会计算部分符号改变值和部分符号改变平均值。最后，使用混合调制技术检测深度伪造。然而，作者提取了空间和频率域特征，并将其融合到知识提炼中，以对深层伪造和真实进行分类 [78]。提取特征的方法是在原始图像和压缩图像上应用 DCT。使用 SKAttention 分三个阶段对提取的特征进行融合，即分割、融合和选择。Xu 等人[47]提出了联合蒸馏和知识转移阶段来进行深度伪造检测。通过探索梯度信息和特征图之间的关系来确定特征的重要性。利用指数衰减规则调整了特征重要性的负转移。作者利用知识提炼和表征学习对深度伪造进行分类[72]。使用迁移学习对特征进行表示，以降低基础模型的计算复杂度。 为了确定视频的完整性，作者建议从每个视频帧中提取 CV 特征[81]。对每个特征计算帧间的变化率，以区分深度伪造和真实视频。同样，Saravana 等人[46] 也提取了多个 CV 特征，但使用的是模糊聚类算法。使用基于 Gabor 滤波器的高斯规则对图像进行预处理，通过消除噪声来提高质量。基于深度信念网络的分类器通过减少检测损失和改进能量函数来对深度伪造与真实伪造进行分类。然而，作者提取了语义信息和上下文信息来检测由换脸技术生成的深度假图[77]。语义信息包括面部区域的边界，而上下文特征则捕捉了头发、耳朵等面部上下文。 生物和生理特征被认为是检测深度伪造视频的最佳视觉描述符。在这方面，Elhassan 等人[45] 利用牙齿和嘴部运动来检测深度伪造视频。在张开嘴露出牙齿的面部图像上，有 68 个地标作为识别假牙的轻量级特征。利用嘴的长宽比和嘴的张开度从面部图像中裁剪出嘴的区域，上下唇均有 12 个点。使用多重 DL 算法对特征进行处理，并使用聚类算法对深度假牙进行分类。 另一方面，作者通过摄像头使用远程照相血压计（rPPG）分析了深度伪造图像中作为生理特征的肤色变化[85]。rPPG 是使用平均 RGB 值的 Chrom 方法对提取区域进行计算的。使用快速傅立叶变换将这些特征转换到频域，并使用功率谱密度识别频率组成。这种方法有效地将深度伪造与真实伪造进行了分类。 要防止欺骗和语音网络钓鱼，就必须确定伪造的音频和语音。为了确定被欺骗的音频，作者将原始波形信号与频谱图融合在一起作为识别特征[87]。使用模型可解释性的 SHAP 方法分析了欺骗语音的特征分布，以解释其可能性。高频范围内的特征相关性被用于真实音频和深度伪造音频的分类。另一方面，Ballesteros 等人[92] 从录音中提取了基于熵的手工特征。这些特征被转换成直方图，用于对深度伪造音频和真实音频进行分类。 总之，我们提取并处理了手工制作的特征，用于识别深度伪造的音频、视频和图像。真实信息和伪造信息之间的差异和变化被识别出来并进行分类比较。对数据进行预处理不仅是为了识别感兴趣的区域，也是为了消除噪声的影响，提高对比度和分辨率。提取的信息使用 DL 模型或 ML 模型进行处理和分类。 基于传统技术的手工特征处理速度快，适合实时处理，但适用性有限。 基于机器学习的算法 这些技术分为基于 ML 的深度赝品检测技术，其中的特征提取采用手工方法或基于 DL 的方法，但使用各种基于 ML 的技术进行分类。 表 5 列出了基于 ML 的深度防伪检测方法的显著特征。基于 ML 的深度伪造检测方法可以轻松地进行训练，并能更快地提供结果。在这方面，Wang 等人[31] 训练了一种 RF 分类器来检测深层赝品。 与真实人物相比，深度赝品的面部点特征较少，而基于 ML 的分类器可通过融合面部区域描述符对其进行有效分类。面部区域描述符是通过整合各种手工特征生成的，如 SIFT（尺度不变特征变换）、SURF、FAST（加速片段测试特征）和 BRIEF（二元鲁棒独立基本特征）、ORB（旋转 BRIEF）和 A-KAZE。RF 还选择了重要的特征来提高检测算法的效率。另一方面，考虑到纹理特征[10]和头部姿势[32]的不一致性，SVM 分类器被用于检测面部区域的变化。 在 [10] 中，作者使用 SVM 对深度防伪检测模型进行了训练和分类。在像素、块和区域三个层次上生成了真实和伪造视频的纹理特征图. 为了在深度伪造检测中获得更好的结果，对多种 ML 算法进行了训练。在这方面，Hamza 等人[28]利用了 RF、MLP（多层感知器）、DT、EXC（额外树分类器）、LR（逻辑回归）、Gaussian NB（奈夫贝叶斯）、AdaBoost、GB（梯度提升）、XGBoost、LDA（线性判别分析）和 QDA（二次判别分析）。总体而言，SVM 的表现优于其他 ML 算法，准确率最高。同样，作者采用了 SVM、MLP、DT、LR、NB 和 XGBoost 等六种 ML 算法对深度伪音频进行真假分类[30]。这些分类器的处理方法是使用 PCA（主成分分析）选择重要特征进行训练。 总之，基于 ML 的深度伪造检测技术是一种轻量级、可解释和可理解的技术，而且处理时间较短。基于 ML 的分类器易于训练，可用于检测使用各种创建技术生成的深度伪造内容。使用传统技术或 DL 模型提取特征，以开发稳健模型。在将融合特征向量输入 ML 分类器之前，采用了特征选择和关键帧选择方法来改进融合特征向量。 基于单模态的深度伪造检测先进技术 基于深度学习的算法 本节将讨论各种基于 DL 的深度防伪检测算法。表 6 列出了深层伪造检测算法类别下的代表性工作。这些算法适用于在高度压缩的低质量视频中检测深度伪造。在这个方向上，Zhu 等人[27]利用高度压缩的深度伪造视频中的时空不一致性提取空间频率特征。利用基于两级师生（ST）网络的时间对比蒸馏模型处理了时间相关信息和结构知识。 同样，作者利用双分支卷积自动编码器进行了深度伪造视频的重建和分类[61]。 使用基于两级学生-教师（ST）网络的时间对比蒸馏模型处理时间相关信息和结构知识。同样，作者利用双分支卷积自动编码器进行深度伪造重建和分类[61]。局部信息和全局信息相结合，并将提取的特征映射到潜在空间，以提高泛化能力。在共享编码器分支中使用了 XceptionNet，在分类器网络的每个全连接层之后使用了 ReLu。作者提出了用于深度伪视频检测的卷积 ViT [65] 多模态深度伪装检测 多模态深度伪造检测强调在输入特征中纳入音频、视频、图像和文本等多种模态，以检测实际场景中的操纵行为。多模态深度伪造检测技术可分为基于 DL 的方法和集合方法。合成生成的多媒体可以使用 DL 架构、转换器进行检测，并使用融合方法对检测结果进行分类。多模态深度伪造检测算法的通用架构如图 9 所示。表 8 列出了归类于这类深度防伪检测算法的代表性工作。下一节将详细介绍用于深度防伪检测的 DL 模型。 基于深度学习的技术 本小节将详细介绍利用 DL 模型进行特征检测、处理和分类的多模态深度防伪检测算法。在这方面，Yoon 等人[50]使用多模态转换器处理了三重模态，即文本、视频和音频。转换器由两个阶段组成，包括特征提取和表示，以及残差连接和后期融合。使用 ReLU 激活函数防止了三种模态交互造成的视觉特征损失。提取并融合蒸馏令牌和多模态数据得分，以获得用于检测深度伪造的分类器概率。在 [49] 中，作者从多模态、音频和视频中提取特征，并使用内模态混合层和间模态混合层将其融合。 音频特征使用残差块进行采样和学习，而视频帧的提取则使用多个残差层和池化层。混合特征被传递给多标签预测头，以学习用于真假分类的补丁。 为了防止在融合多模态数据上训练的模型出现不确定性，作者提","date":"2025-04-09","objectID":"/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%A0%94%E7%A9%B6/%E7%BB%BC%E8%BF%B0/:0:0","tags":null,"title":"综述","uri":"/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%A0%94%E7%A9%B6/%E7%BB%BC%E8%BF%B0/"},{"categories":null,"content":"Attention(注意力机制) 对于一堆数据，我们想使用重要的数据，不使用不重要的数据，但是对一个模型而言它很难决定哪些重要，哪些不重要。 注意力机制就是把注意力聚焦在比较重要的事物上 一些概念QKV ","date":"2025-04-03","objectID":"/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%A0%94%E7%A9%B6/transformer/:0:0","tags":null,"title":"Transformer","uri":"/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%A0%94%E7%A9%B6/transformer/"},{"categories":null,"content":"Python 迭代器详解 目录 基本概念 创建迭代器 迭代器特性 常见迭代器类型 迭代器协议 注意事项 实际应用 最佳实践 基本概念 迭代器 vs 可迭代对象 特征 可迭代对象 (Iterable) 迭代器 (Iterator) 定义 可返回迭代器的对象 实现__iter__和__next__的对象 内存消耗 通常存储完整数据 按需生成数据，节省内存 状态保持 无状态 保持遍历状态 示例 list, tuple, dict, str generator, file object 迭代器核心特征 一次性消费：遍历后无法重置 惰性求值：按需生成元素 内存高效：适合处理大数据集 创建迭代器 1. 内置函数转换 numbers = [1, 2, 3] my_iter = iter(numbers) # 创建迭代器 迭代器只能遍历一次 我们编写如下代码： a = [1,2,3] b = iter(a) for i in b: print(i) print(\"*****\") for i in b: print(i) 运行该代码该代码将输出： 1 2 3 ***** 你会发现在第二次输出时并没有任何输出。 常见迭代器类型 类型 描述 注意事项 文件对象 open()返回的对象 读取后需重新打开 生成器 使用yield的函数 自动实现迭代器协议 map/filter 函数式编程操作结果 结果只能遍历一次 zip/enumerate 组合迭代工具 按最短输入截断 csv.reader CSV文件读取器 需转换为列表持久化数据 迭代器协议 必须实现的方法 __iter__(): 返回迭代器自身 __next__(): 返回下一个元素，耗尽时抛出StopIteration 比如一个自己实现的迭代器如下： class CountDown: def __init__(self, start): self.current = start def __iter__(self): return self def __next__(self): if self.current \u003c= 0: raise StopIteration num = self.current self.current -= 1 return num for n in CountDown(3): print(n) # 输出 3 2 1 如何重复使用迭代器数据 将其转换为列表 data = list(csv_reader) 使用一些其他的包 import itertools iter1, iter2 = itertools.tee(original_iter, 2) ","date":"2025-03-26","objectID":"/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/python%E8%BF%AD%E4%BB%A3%E5%99%A8/:0:0","tags":null,"title":"Python迭代器","uri":"/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/python%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":null,"content":"Django5框架简介 Django是用python语言写的开源web开发框架，对比Flask框架，Django原生提供了更多的功能组件，一般来说，要构建大型项目可以使用Django框架，小型项目可以使用Flask框架。 Django框架内部架构使用的是MVT设计模式。 MVC模式与MVT模式 MVC模式的定义如下： M 全拼为 Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V 全拼为 View，用于封装结果，生成页面展示的 html 内容。 C 全拼为 Controller，用于接收请求，处理业务逻辑，与 Model 和 View 交互，返回结果。 MVT模式的定义如下： M 全拼为 Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。 V 全拼为 View，与 MVC 中的 C 功能相同，接收请求，进行业务处理，返回应答。 T 全拼为 Template，与 MVC 中的 V 功能相同，负责封装构造要返回的 html。 Django5安装 用pip即可安装 pip install Django==5.0.1 在安装完成后，会多出一些文件。 python目录下的scripts目录下会多出一个django-admin.exe，这是Django的项目创建工具 lib下的site-packages目录下会多出一个django目录 创建项目 在cmd中输入以下指令即可 django-admin startproject test 项目在创建完成后将生成以下目录： └─test_django │ manage.py │ └─test_django asgi.py settings.py urls.py wsgi.py __init__.py manage.py 项目管理命令行工具，内置多种方式与项目进行交互，包括启动项目，创建app，数据管理等等。不用修改该文件(脚手架文件) settings.py 项目的配置文件，项目中的所有功能都需要在这里配置 urls.py 项目的路由配置，设置网站的具体网址内容 wsgi.py 全称python web server gateway interface，即python服务器网关接口，是python应用与web服务器之间的接口，用于django项目在服务器上的部署和上线，也不用修改，本质上来说启动server就是manage调用wsgi asgi.py 开启一个asgi服务，asgi是异步网关协议接口，也不用修改 asgi与wsgi代码几乎一致，只不过一个是同步一个是异步。 核心要修改的文件就是urls和settings.py 输入 python manage.py help可以查看相关的指令： python .\\manage.py help Type 'manage.py help \u003csubcommand\u003e' for help on a specific subcommand. Available subcommands: [auth] changepassword createsuperuser [contenttypes] remove_stale_contenttypes [django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate optimizemigration sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver [sessions] clearsessions [staticfiles] collectstatic findstatic runserver 如何启动项目 正如在上一个指令中所展示的那样，输入： python manage.py runserver 运行成功后访问本机8000端口即可得到如下界面： 可以使用如下参数指定端口与ip python manage.py runserver 0:0:0:0:8888 不过你得将这个ip添加到settings里面的allowed hosts里面。 快速使用Django展示数据（创建子应用） 要想将你的内容展示到网页上，需要以下三个步骤： 创建子应用 在子应用的视图文件views.py中编写视图函数 把视图函数和url进行绑定并注册到django项目中 首先输入以下代码： python manage.py startapp goods 注意这里创建app一般是在根目录下面创建。 在创建一个app后我们进入其中查看一下目录结构： cd goods tree 卷序列号为 5449-63C5 C:. │ admin.py │ apps.py │ models.py │ tests.py │ views.py │ __init__.py │ └─migrations __init__.py migrations 这是一个数据迁移文件，同步模型到数据库，一般是不动的 views 让我们看一下views里面有什么 from django.shortcuts import render # Create your views here. 你会发现里面空空如也，实际上你要在这里编写你的views。 我们写一个视图函数，在这里我先说明一下什么是视图函数，视图函数简称视图，他其实与普通的python函数并无区别，他只是可以接受web请求并返回web响应。视图层中有两个重要的对象：请求对象(request)与响应对象(HttpResponse)。 现在让我们在views里编写一个简单的视图函数： from django.shortcuts import render from django.http.response import HttpResponse # Create your views here. def index(request): # 业务代码 return HttpResponse(\"ok\") 在写完视图之后，要编写路由，路由就在urls.py里面，编写这个文件： 原始文件： from django.contrib import admin from django.urls import path urlpatterns = [ path('admin/', admin.site.urls), ] 修改为： from django.contrib import admin from django.urls import path from goods import views urlpatterns = [ path('admin/', admin.site.urls), path('index/', views.index), ] 然后你便可以通过http://127.0.0.1:8000/index/来访问函数的返回结果了，实际上之前的代码返回了一个“ok”，你也可以返回html格式的代码。比如： return HttpResponse(\"\u003ch1\u003eok\u003c/h1\u003e\", content_type=\"text/html\") 视图一定要绑定路由。 子应用的名称将来会作为目录名存在，要符合python的命名规范，不要使用数字啥的。 web开发相关网络知识 ","date":"2025-03-19","objectID":"/python%E5%BC%80%E5%8F%91/django5%E6%A1%86%E6%9E%B6/:0:0","tags":null,"title":"Django5框架","uri":"/python%E5%BC%80%E5%8F%91/django5%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"本文主要介绍python中的类，当然本目录主要是讲述python开发，在这里记录python中的类主要是由于作者本人未对python中的类掌握的足够好。 类 封装，继承与多态是面向对象编程最核心的概念。 类的定义 在python中使用class关键字定义一个类，类中可以包含属性与行为，一个简单的示例如下： class Test(): def __init__(self): self.name = \"仅仅是一个测试\" def out_name(self): print(self.name) if __name__ == \"__main__\": t = Test() print(t.name) t.out_name() 这段代码将有如下输出： 仅仅是一个测试 仅仅是一个测试 self是python中的关键字，这个关键字在写方法时必须存在。 构造方法 __init__()方法是构造方法，在创建类对象时会自动执行。 魔术方法 __init__()是python类内置的方法之一，这些内置的类方法各自有各自特殊的功能，这些内置方法就是“魔术方法”。 封装 私有成员变量与私有成员方法 定义私有成员的方法非常简单，只需要在（无论变量还是方法）前面加两个下划线即可。 编写如下代码： class Test(): father = \"z\" __mather = \"p\" def __init__(self): self.name = \"仅仅是一个测试\" def out_name(self): print(self.name) if __name__ == \"__main__\": t = Test() print(t.name) t.out_name() print(t.father) print(t.mather) 运行之后将会报错： Traceback (most recent call last): File \"C:\\Users\\76290\\PycharmProjects\\pythonProject1\\test.py\", line 17, in \u003cmodule\u003e print(t.mather) ^^^^^^^^ AttributeError: 'Test' object has no attribute 'mather'. Did you mean: 'father'? 仅仅是一个测试 仅仅是一个测试 z 不过仍然可以通过别的方式访问： class Test(): father = \"z\" __mather = \"p\" def __init__(self): self.name = \"仅仅是一个测试\" def out_name(self): print(self.name) def out_mather(self): print(self.__mather) if __name__ == \"__main__\": t = Test() print(t.name) t.out_name() print(t.father) t.out_mather() 这段代码将输出： 仅仅是一个测试 仅仅是一个测试 z p 也就是说类里面的其他成员是可以使用这些私有变量和方法的。 继承 继承的写法如下： class Test(): father = \"z\" __mather = \"p\" def __init__(self): self.name = \"仅仅是一个测试\" def out_name(self): print(self.name) def out_mather(self): print(self.__mather) class Test2(Test): grandfather = \"zz\" class 类名(父类名)这称为单继承。 python同样支持多继承，即一个类继承多个父类。 class 类名(父类1，父类2，父类3).如果父类有重名变量的话，那么左边的优先，即谁先来的谁优先级高。 继承也支持复写，可以直接将父类的属性覆盖掉。 调用父类同名成员 一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员。如果需要使用被复写的父类的成员，需要特殊的调用方式： 父类名.成员变量 父类名.成员方法(self) 使用super()调用父类成员 super().成员变量 super.成员方法() 注意方法一需要传入self，方法二不需要传入self。 类型注解 类型注解可以帮助IDE对代码进行类型推断，协助做代码提示。 类型注解分为两种： 变量的类型注解 函数（方法）形参列表和返回值的类型注解 基础语法就是 变量：类型 比如： var1: int = 10 多态 多态指的是完成某个行为时使用不同的对象会得到不同的状态。 举一个例子： class Animal: def speak(self): pass class Dog(Animal): def speak(self): print(\"www\") class Cat(Animal): def speak(self): print(\"mmm\") if __name__ == \"__main__\": def make_noise(animal: Animal): animal.speak() dog = Dog() cat = Cat() make_noise(dog) make_noise(cat) 运行这段代码将输出： www mmm 根据传入的对象不同得到的输出也不同。 多态的另一个用处是抽象类(接口)，比如上一段代码中的Animal类的speak方法是一个pass，这样设计的含义是父类用来确定有哪些方法，具体如何实现由子类自行决定。这种写法，就叫做抽象类（也可以称之为接口），此外，含有抽象方法的类称为抽象类，方法体是空实现（pass）的称之为抽象方法。 一些小知识点 Q1 class Test()与class Test有什么区别？ 在python3中并无区别，在python3中推荐省略括号，仅在需要继承其他类时使用括号。 ","date":"2025-03-19","objectID":"/python%E5%BC%80%E5%8F%91/python%E5%AF%B9%E8%B1%A1/:0:0","tags":null,"title":"Python对象","uri":"/python%E5%BC%80%E5%8F%91/python%E5%AF%B9%E8%B1%A1/"},{"categories":["python开发"],"content":"test tets' test ","date":"2025-03-19","objectID":"/python%E5%BC%80%E5%8F%91/hello_world/:0:0","tags":["python"],"title":"Hello_world","uri":"/python%E5%BC%80%E5%8F%91/hello_world/"},{"categories":["draft"],"content":" Git在工作中经常用到，然后我相信包括我在内大部分人应该都停留在简单的clone,push,pull等等简单的操作上（虽然大部分时候也确实够用了😂）。不过在遇到冲突的时候合并冲突的时候脑子就会一团浆糊，因此我最近仔细学习了一遍git~从命令到原理，希望这篇文章可以帮助到阅读这篇文章的人😉 版本控制 版本控制是一个项目开发中非常重要的一环，举一个例子，如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。 为了解决这个问题，人们开发了许多中本地版本控制系统，大多都是采用简单的数据库来记录。但是还有一个非常重要的问题必须解决，那就是如果有多个开发者该怎么办？本地记录固然方便，但是不能解决多个系统的多开发者问题。 集中化的版本控制系统 集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 分布式版本控制系统 于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 Git下文件的三种状态 Git有三种状态，分别是已提交(committed)，已修改(modified)和已暂存(staged).对应的，Git项目有三个区域，分别是工作区（工作目录），暂存区（索引）、Git目录（git仓库）。 工作区： os上的文件，所有的代码开发编辑在这上面完成，其实这里的工作区就是实际上你操作的文件夹。 暂存区： 可以理解为一个暂存区域，这里面的代码会在下一次commit被提交到Git仓库。不过其实暂存区是一个文件，它保存了下次将要提交的文件列表信息，一般在Git的仓库目录中，按照git的术语叫做“索引”。 Git仓库： 由Git object记录着每一次提交的快照，以及链式结构记录的提交变更历史。这是Git中最重要的部分，从其他计算机克隆仓库时，复制的就是这里的数据。 基本的工作流程就是： 在工作区修改文件 将你想要下次提交的更改选择性暂存 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 Git下的一些基本指令 获取git仓库 有两种方式可以获得Git项目仓库： 将一个不是Git仓库的本地目录转换为Git仓库 从其他服务器克隆一个已经存在的Git仓库 方法一（初始化仓库） git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 如果你想追踪某些文件并进行初始提交，可以按如下流程： git add xxx git commit -m 'xxxx' 方法二（克隆一个现有的仓库） git clone https://github.com/libgit2/libgit2 你也可以自定义本地仓库的名字： git clone https://github.com/libgit2/libgit2 xxx Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 一个简单的提交更新的流程 要记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。在这里你可以认为“已跟踪就是你git add 的文件，而未跟踪就是没有被add过的文件（本博客作者拙见）”。 上面这四个状态分别是未追踪，未修改，已修改和已暂存。 我相信你应该可以根据这四个词的意思大致推断出每个状态的含义。 未被add的文件（从未被add）是未追踪状态 add一个文件后该文件变为暂存状态 git status查看文件状态 git status是一个非常有用的指令，它可以帮助你明白你接下来要干什么，限于篇幅（一个人可以专注阅读的最大文字）这里仅仅做一个简单展示（强烈建议你自己在新建一个git仓库后使用add，commit等指令后尝试输入git status试一下）。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： $ git status On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working directory clean 这个命令会告诉你当前的分支名称，工作目录中文件的状态等等。 忽略文件 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子： $ cat .gitignore *.[oa] *~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件. 查看已暂存和未暂存的修改 git diff 可以具体的显示哪些行发生了改变 提交更新 git commit -m ‘xxx’ 如果你不想使用暂存区域，你可以使用git commit -a -m 'xxx'来直接进行提交，使用这个命令Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 查看历史提交 git log 撤销操作 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令来重新提交： git commit --amend 这个命令作者的理解是可以覆盖上一次的-m中的内容。（他是用一个新的提交替换旧的提交，因此旧提交不会出现在历史中） 取消暂存的文件 假设我们现在修改两个文件： echo 111 \u003e\u003e a.txt echo 111 \u003e\u003e b.txt 我们本来想git add a.txt但是一不小心使用了’git add *’，那么该如何将b.txt取消暂存呢？ 我们输入git status试一下： $ git status On branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: 1.txt modified: a.txt modified: b.txt git status 告诉我们“use “git restore –staged …” to unstage”，请注意这里与官方的教程中“use “git reset HEAD …” to unstage”并不一样，这是因为古早的git reset承载了太多的功能，而git restore是在Git 2.23版本（2019年）引入的新命令，作为更清晰、更专门化的命令之一，与git switch一起被引入，旨在分解git checkout的功能，使得各个命令的职责更明确。 因此我们输入： $ git restore --staged b.txt $ git status On branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: 1.txt modified: a.txt Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: b.txt 撤销对文件的修改 如果我不想保留对某一个文件的修改怎么办呢？（如何将它还原成之前某一个时刻的状态？） 注意看上一个条目的第二段： Changes not staged for co","date":"2025-03-12","objectID":"/posts/9ed4b52/:0:0","tags":["draft"],"title":"Git从入门到精通","uri":"/posts/9ed4b52/"},{"categories":["python"],"content":"之前有一段时间被python的引用搞得头昏脑胀，学了之后现在再看已经记不太清了，于是特来记录一番. 一些基本概念 script 脚本是一个python文件，可以直接运行，但是一般不包含类呀class呀或者一些变量的定义，只是用来执行 module 模块是一个变量，数组，函数和类的集合.模块是一种以.py为后缀的文件，用于表示程序的一部分，模块的名称是该py文件的名称 package 包是指一个文件夹中包含很多module（几个模块的集合）。包体现了模块的机构化管理思想。老版本必须在文件夹下放一个__init__.py，不然不识别，现在可有可无，不过建议加上,该目录下的文件被视为一个单一的包。 #目录结构 . |-- creatures | |-- __init__.py | |-- ch.py | |-- moster.py |-- magic |-- __init__.py |-- magic.py library 一个库是几个包的集合。python中的库并没有具体的定义，着重强调其功能性。 framework 框架，框架与库类似，往往集成了多种库的功能。 if name==’main': 假设在同一目录下有两个文件m1.py与m2.py 其中m1的内容如下： def f1(): print(\"this is m1\") m2内容如下： from m1 import f1 f1() 执行m2.py，输出将为： this is m1 this is m1 但是如果我们修改m1.py的内容为： def f1(): print(\"this is m1\") if __name__=='__main__': f1() 那么此时再运行m2就会输出一个m1. okay,现在来探究一下__name__.我们现在在m1.py的代码中加入一行代码： def f1(): print(\"this is m1\") print(__name__) if __name__=='__main__': f1() 此时再次执行m1.py，屏幕中将输出： __main__ this is m1 再次执行m2.py,屏幕将输出： m1 this is m1 也就是说在运行m1的时候__name__将等于__main__,而在运行m2时m1中的__name__变为了m1。 name这个变量编译器会自动定义，可以通过print(dir())显示。 修改m1的代码为： print(dir()) def f1(): print(\"this is m1\") print(__name__) a=34 print(dir()) if __name__=='__main__': f1() 执行m1，将输出： ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__'] ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'f1'] this is m1 __main__ 看到这里，我们要知道两个事情，第一个事情是我们在import一个模块时，会自动运行这个模块中的所有代码，这与引用的形式无关，如果你不想执行那么就使用__name__.第二点是不管import几次，同一个文件只会执行一次（解释器发现第一次已经加载了，第二次便不加载了）。 sys 编写一段python代码如下： import sys print(sys.path) 代码将输出 ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] 这是一个列表，当你在运行一个代码时，python会在这些路径里查找你要引用的模块。 如果找不到要引用的那个包，那么有两种方法来解决。 现在的目录如下： . ├── m1.py ├── m2.py ├── pkg │ ├── __pycache__ │ │ └── run.cpython-312.pyc │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 如果想在m2.py中引用run.py，假设这样写： #m2.py from m1 import f1 import m1 import run import sys print(sys.path) f1() 代码将会报错，这是因为python在当前的path中找不到run，此时可以这样解决： 使用绝对路径引用 #m2.py from m1 import f1 import m1 import pkg.run import sys print(sys.path) f1() 这种方法可以成功是因为pkg位于根目录package下面，python可以找到pkg。 可以手动将m2的路径添加到path中 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') 相对引用（容易犯错） 当前我们的文件目录如下： . └── package ├── m1.py ├── m2.py ├── pkg │ ├── __pycache__ │ │ └── run.cpython-312.pyc │ ├── run2.py │ └── run.py └── __pycache__ └── m1.cpython-312.pyc 此时四个代码文件依次如下： #m1.py import sys print(sys.path) def f1(): print(\"this is m1\") if __name__=='__main__': f1() #m2.py import sys import m1 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') import pkg.run2 #run.py def run1(): print(\"this run1\") run1() #run2.py from .run import run1 def run2(): print(\"this run2\") run1() 此时运行m2.py，代码将输出： ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] this run1 this run1 第一个输出的列表是m2中引用m1时运行m1中的代码print(sys.path)输出的。 第二个输出是run2引用run1时执行run1时得到的 第三个输出时run2自己执行run1()得到的 😉 假设我们将m2的代码修改为： import sys import m1 sys.path.append('/home/zzh/data/attack_based_steal/imp/package/pkg') import run2 代码将直接报错： ['/home/zzh/data/attack_based_steal/imp/package', '/opt/anaconda3/lib/python312.zip', '/opt/anaconda3/lib/python3.12', '/opt/anaconda3/lib/python3.12/lib-dynload', '/opt/anaconda3/lib/python3.12/site-packages'] Traceback (most recent call last): File \"/home/zzh/data/attack_based_steal/imp/package/m2.py\", line 5, in \u003cmodule\u003e import run2 File \"/home/zzh/data/attack_based_steal/imp/package/pkg/run2.py\", line 1, in \u003cmodule\u003e from .run import run1 ImportError: attempted relative import with no known parent package 😉 注意这里报错并不是因为m2没有引用到run2。这里的报错与直接执行run2的报错相同。若直接执行run2，代码将报错： Traceback (most recent call last):","date":"2025-03-10","objectID":"/posts/2146d33/:0:0","tags":["python"],"title":"Python中的引用","uri":"/posts/2146d33/"},{"categories":["语法"],"content":"Markdown语法","date":"2025-03-06","objectID":"/posts/6874887/","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["语法"],"content":"为什么我们需要markdown文档呢？ 一些主要好处在于： Markdown简单易学，没有多余字符，编写内容较快 用Markdown书写时出错的机会更少 可以将内容与视觉显示保持分开 interesting~ 标题 从 h2 到 h6的标题在每个级别上都加上一个 # ： ## 标题 ### 标题 #### 标题 ##### 标题 ###### 标题 你还可以添加自定义标题的ID，只需要在标题相同的行中将自定义ID放在花括号中： ### 标题 {#custom-id} 这类似于html中的 \u003ch3 id=\"custom-id\"\u003e标题\u003c/h3\u003e 注释 注释与html语言中的注释一样 \u003c!-- 你看不到我 --\u003e 水平线 在html中，水平线用 \u003chr\u003e 标签表示。在markdown中，用下面三种方式： ___ 三个连续的下划线 — 三个连续的破折号 *** 三个连续的星号 呈现效果如下： 段落 直接按照纯文本的方式即可输出段落，不需要html中用\u003cp\u003e\u003c/p\u003e标签包裹 使用一个空白行来进行换行 强调 加粗 用于强调带有较粗字体的文本片段。 以下文本片段会被 渲染为粗体 **渲染为粗体** __渲染为粗体__ 斜体 以下文本将被 渲染为斜体 *斜体* _斜体_ 删除线 这段文本将被删除 ~~删除线~~ 组合 加粗，斜体和删除线可以组合使用 引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加 \u003e : 效果如下 这是一段引用，注意要使用引用的话，箭头应该在一行的行首同时引用也可以嵌套，二级引用是两个箭头 \u003e 这是一段引用 列表 无序列表 无序列表没有标号 可以使用如下符号来进行表示： * 一项 - 一项 + 一项 例如： * test * test * test * test * test * test 呈现的效果如下： test test test test test test 有序列表 就是带标号的列表 1. test 2. test 3. test 呈现的效果如下： test test test tips 如果你对每一行都是用1. 来进行标号，那么markdown将会自动为每一项标号 代码 行内代码 用 `包装行内代码 tips 如果要包裹的行内代码内包含 ` 可以使用连续的双引号来进行包裹 在这个例子中，`行内代码`将被包裹 效果如下： 在这个例子中，行内代码将被包裹 围栏代码块 使用围栏 ```来生成一段带有语言属性的代码块。 ``` markdown text here 输出的效果如下： text here 表格 通过在每个单元格之间添加竖线作为分割线，并在标题下添加一行破折号（也由竖线分割）来创建表格，竖线并不需要竖直对齐 | option | des | | ------ | --- | | data | how are u ? | 呈现的效果如下： option des data how are u ? tips 文本右对齐与居中对齐 在任何标题下方的破折号右侧添加冒号将使该列文本右对齐，在任何标题下方的破折号两侧添加冒号将使该列文本居中对齐 | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的效果如下： Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 链接 基本链接 \u003chttps://www.baidu.com\u003e [bilibili](https://www.bilibili.com/) 呈现的效果如下： https://www.baidu.com bilibili 引用式链接 引用式链接是一种特殊的链接，它使URL在markdown中更易于显示和阅读。 引用式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。 [text][id] ··· [id]: http://example.org/ \"title\" 例如： [fixit][fixit-repo] [fixit-repo]: https://github.com/hugo-fixit/FixIt \"A clean, elegant but advanced blog theme for Hugo\" 呈现的效果如下： fixit 定位标记 定位标记允许你跳转至同一页面上的指定锚点。例如，每个章节： ## Table of contents * [Ch1](#chapter-1) * [Ch2](#chapter-2) 将跳转到这些部分： ## Ch1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e content ## Ch2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e 图片 图片的语法与链接相似，只不过要加一个感叹号 ![Minion](url) 或者 ![text](url) emoji表情支持 emoji表情有多种方式可以在hugo项目中使用。 真开心！ :joy: 效果如下： 真开心！ 😂 更多表情请参考emoji代码~ ","date":"2025-03-06","objectID":"/posts/6874887/:0:0","tags":["markdown"],"title":"Markdown语法","uri":"/posts/6874887/"},{"categories":["draft"],"content":"这是 粗体 文本，这是 斜体 文本。 访问 Hugo 网站！ 123123 ","date":"2025-03-05","objectID":"/posts/10efd1f/:0:0","tags":["draft"],"title":"Test","uri":"/posts/10efd1f/"},{"categories":["hello"],"content":"Welcome to Hugo FixIt! This is your very first post. Documentation Head to the documentation page linked below for a complete guidence to get started with the FixIt theme. InstallationGetting StartedContent ManagementAdvanced Usage Feedback Whether it’s questions, ideas, bugs or pull requests, all feedback is welcome! Head over to the issues or discussions tracker. ","date":"2025-03-04","objectID":"/posts/hello-world/:0:0","tags":["hello","FixIt"],"title":"Hello World","uri":"/posts/hello-world/"}]